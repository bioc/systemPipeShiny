% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spsClasses.R
\name{plotContainer}
\alias{plotContainer}
\title{SPS snapshots container}
\description{
Initiate this container at the global level, this is done
for you in \emph{global.R} and you only need to call the \code{sps_plots} object when
you need methods from this class.

This container is used to communicate plotting tabs with the canvas tab.
}
\examples{
# a simple example to show how the snapshots communicates with Canvas
if(interactive()){
    library(shiny)
    library(shinydashboard)
    library(shinyjs)
    plots = plotContainer$new()
    mod1_UI <- function(id) {
        ns <- NS(id)
        tagList(
            h1("a tiny example of how Canvas work in SPS"),
            actionButton(ns("render"), "render"),
            jqui_resizable(plots$addUI(plotlyOutput(ns("plot1")), id)),
            sliderInput(ns("slide"), label = "rows",
                        min = 1, max = nrow(iris),
                        value = nrow(iris))

        )
    }
    mod1 <- function(input, output, session, shared) {
        observeEvent(input$render, {
            output$plot1 <- plots$addServer(renderPlotly, 'mod1', {
                ggplotly(ggplot(iris[1:input$slide, ],
                                aes(Sepal.Length, Sepal.Width)) +
                             geom_point(aes(colour = Species)))
            })
            shared$snap_signal <- plots$notifySnap("mod1")
            req(shared$snap_signal)
            toastr_info(
                glue("Snapshot {glue_collapse(shared$snap_signal, '-')}",
                     "added to canvas"),
                        position = "bottom-right")
        })
    }
    mod2_UI <- function(id){
        ns <- NS(id)
        tagList(
            actionButton(ns("refresh"), 'refresh'),
            sliderTextInput(
                inputId = ns("ncols"),
                label = "Number of columns per row to initiate canvas:",
                choices = c(1:4, 12), selected = 2, grid = TRUE
            ),
            fluidRow(uiOutput(ns("new")), class = "sps-canvas")
        )
    }

    mod2 <- function(input, output, session, shared) {
        ns <- session$ns
        make_plots <- reactiveValues(ui = list(), server = list())
        observeEvent(shared$snap_signal, {
            tab_id <- shared$snap_signal[1]
            new_plot_id <- glue("{tab_id}-{shared$snap_signal[2]}")
            print(new_plot_id)
            make_plots$ui[[new_plot_id]] <-
                list(plots$getUI(tab_id, ns(new_plot_id)), ns(new_plot_id))
            make_plots$server[[new_plot_id]] <- plots$getServer(tab_id)
        })
        observeEvent(input$refresh, {
            ui <- make_plots$ui
            output$new <- renderUI({
                sapply(seq_along(ui), function(i){
                    column(
                        width = 12/isolate(input$ncols),
                        class = "collapse in",
                        id = glue("{ui[[i]][2]}-container"),
                        div(class = "snap-drag bg-primary",
                            h4(glue("Plot {ui[[i]][2]}")),
                            tags$button(
                                class = "btn action-button canvas-close",
                                icon("times"),
                                `data-toggle`="collapse",
                                `data-target`=glue("#{ui[[i]][2]}-container"),
                                `plot-toggle` = ui[[i]][2]
                            )
                        ),
                        jqui_resizable(make_plots$ui[[i]][[1]]),
                        tags$script(glue(.open = '@', .close = '@',
                                         '$("#@ui[[i]][2]@-container")',
                                         '.draggable({ handle: ".snap-drag"})'))
                    )
                }, simplify = FALSE) \%>\%{
                    fluidRow(id = ns('plots'),
                             tags$head(tags$style(
                                 '
                             .snap-drag {
                             opacity: 0;
                             };'),
                                 tags$style(
                                     '
                             .snap-drag button{
                             position: absolute;
                             outline: none;
                             background-color: Transparent;
                             top: 2px;
                             right: 4px;
                             };'),
                                 tags$style(
                                     '
                             .snap-drag h4{
                             margin-bottom: 0;
                             padding-bottom: 10px;
                             };'),
                                 tags$style(
                                     '
                             .snap-drag button:focus {
                             outline: 0 !important;
                             box-shadow: none !important;
                             };'),
                                 tags$style('.snap-drag:hover {
                             opacity: 1;
                             }
                             '
                                 )),
                             tagList(.)
                    )
                }
            })
            for(plot_id in names(make_plots$server)){
                output[[plot_id]] <- make_plots$server[[plot_id]]
            }
        })
        observeEvent(input$hide_title, {
            shinyjs::toggleClass(selector = ".snap-drag", class = "collapse")
        })

    }
    ui <- dashboardPagePlus(
        header = dashboardHeaderPlus(),
        sidebar = dashboardSidebar(),
        body = dashboardBody(
            useShinyjs(),
            useSps(),
            mod1_UI("mod1"),
            mod2_UI("mod2")),
        title = "Test",
    )
    server <- function(input, output, session) {
        shared = reactiveValues()
        callModule(mod1, "mod1",  shared)
        callModule(mod2, "mod2",  shared)
    }
    shinyApp(ui, server)
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{plot_ui}}{a list of plot UI snapshots will be stored here.
You shouldn't manually edit this list, use \code{add/getUI} method}

\item{\code{plot_server}}{a list of plot server snapshots will be stored
here. You shouldn't manually edit this list, use \code{add/getServer}
method}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{plotContainer$new()}}
\item \href{#method-addUI}{\code{plotContainer$addUI()}}
\item \href{#method-getUI}{\code{plotContainer$getUI()}}
\item \href{#method-addServer}{\code{plotContainer$addServer()}}
\item \href{#method-getServer}{\code{plotContainer$getServer()}}
\item \href{#method-notifySnap}{\code{plotContainer$notifySnap()}}
\item \href{#method-clone}{\code{plotContainer$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
initialize a new class container
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$new()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addUI"></a>}}
\if{latex}{\out{\hypertarget{method-addUI}{}}}
\subsection{Method \code{addUI()}}{
add plot UI to the container. use it to wrap around the original plot
out put function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$addUI(plot_DOM, tab_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plot_DOM}}{Plotting output function, like \code{plotOutput}}

\item{\code{tab_id}}{unique ID, usually use in a module and use the tab ID}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getUI"></a>}}
\if{latex}{\out{\hypertarget{method-getUI}{}}}
\subsection{Method \code{getUI()}}{
Get plot UI to the container.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$getUI(tab_id, plot_id_new = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tab_id}}{unique ID, usually the tab ID if used in a module}

\item{\code{plot_id_new}}{string, usually if taking a
snapshot of a plot DOM,
they can't use the same ID on HTML. When get the UI, change the ID
to a new value}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a saved plotting DOM
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addServer"></a>}}
\if{latex}{\out{\hypertarget{method-addServer}{}}}
\subsection{Method \code{addServer()}}{
add plot server function to the container. use it to wrap around the
original plot output server function, like \code{renderPlot},
\code{renderPlotly}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$addServer(
  render_func,
  tab_id,
  expr,
  env = parent.frame(),
  quoted = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{render_func}}{plot output server function}

\item{\code{tab_id}}{unique ID, usually the tab ID if used in a SPS tab}

\item{\code{expr}}{the reactive expression to render the plot,
same as \code{expr}
in other render function}

\item{\code{env}}{default \code{parent.frame()}, see shiny documents}

\item{\code{quoted}}{Is you \code{expr} quoted?}

\item{\code{...}}{additional args to pass to the original render function}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getServer"></a>}}
\if{latex}{\out{\hypertarget{method-getServer}{}}}
\subsection{Method \code{getServer()}}{
Get plot UI to the container.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$getServer(tab_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tab_id}}{unique ID, usually the tab ID if used in a module}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
saved plot server function
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-notifySnap"></a>}}
\if{latex}{\out{\hypertarget{method-notifySnap}{}}}
\subsection{Method \code{notifySnap()}}{
notify the snapshot tab a snapshot has been added
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$notifySnap(tab_id, skip = 1, reset = FALSE, set_to = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tab_id}}{unique ID, usually the tab ID if used in a module}

\item{\code{skip}}{positive integer, This function is usually bound to the
plotting button. When clicked, the first number of \code{skip} clicks will
not add the snapshot to the canvas tab.}

\item{\code{reset}}{bool, to reset the count and return nothing}

\item{\code{set_to}}{positive integer, reset the count of a tab to be a
certain number}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a vector of \code{tab_id} and count number as a character string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{plotContainer$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
