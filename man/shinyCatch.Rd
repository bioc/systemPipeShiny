% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spsServerCollections.R
\name{shinyCatch}
\alias{shinyCatch}
\title{Shiny exception handling}
\usage{
shinyCatch(
  expr,
  position = "bottom-right",
  blocking_level = "none",
  shiny = TRUE
)
}
\arguments{
\item{expr}{expression}

\item{position}{client side message bar position, one of:
c("top-right", "top-center", "top-left","top-full-width", "bottom-right",
"bottom-center", "bottom-left","bottom-full-width").}

\item{blocking_level}{what level you want to block the execution, one
of "error", "warning", "message"}

\item{shiny}{bool, It is also possible to use without a shiny session. Only
shows on console log, works very similar as \code{\link[=tryCatch]{tryCatch()}} and can block at
multiple levels}
}
\value{
see description
}
\description{
Exception in Shiny apps can crash the app. Most time we don't
want the app to crash but just stop this block, inform users and continue
with other code blocks. This function is designed to handle these issues.
}
\details{
Show error, warning, message by a toast bar on client end and
also log the text on backend console. It will return original value if not
blocking at "warning" "message" level, and return \code{NULL} at error level.
If blocks at \code{error}, function will be stopped and other code in the same
reactive context will be blocked. If blocks at \code{warning} level, warning and
error will be blocked; \code{message} level blocks all 3 levels. The blocking works
similar to shiny's \code{\link[shiny:req]{shiny::req()}} and \code{\link[shiny:validate]{shiny::validate()}}.
If anything inside fails, it will
block the rest of the code in your reactive expression domain.

Messages will be displayed for 3s, 5s for warnings and errors will never
go away on UI unless users' mouse hover on the bar or manually close it.
}
\examples{
if(interactive()){
    ui <- fluidPage(
        useSps(),
        actionButton("btn1","error and blocking"),
        actionButton("btn2","error no blocking"),
        actionButton("btn3","warning but still returns value"),
        actionButton("btn4","warning but blocking returns"),
        actionButton("btn5","message"),

        textOutput("text")
    )
    server <- function(input, output, session) {
        fn_warning <- function() {
            warning("this is a warning!")
            return(1)
        }
        observeEvent(input$btn1, {
            shinyCatch(stop("error with blocking"), blocking_level = "error")
            print("You shouldn't see me")
        })
        observeEvent(input$btn2, {
            shinyCatch(stop("error without blocking"))
            print("I am not blocked by error")
        })
        observeEvent(input$btn3, {
            return_value <- shinyCatch(fn_warning())
            print(return_value)
        })
        observeEvent(input$btn4, {
            return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
            print(return_value)
            print("other things")
        })
        observeEvent(input$btn5, {
            shinyCatch(message("message"))
        })
    }
    shinyApp(ui, server)
}
#outside shiny examples
shinyCatch(message("this message"), shiny = FALSE)
try({shinyCatch(stop("this error"), shiny = FALSE); "no block"}, silent = TRUE)
try({shinyCatch(stop("this error"), shiny = FALSE, blocking_level = "error")
    "blocked"}, silent = TRUE)
}
