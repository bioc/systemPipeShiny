---
title: "RNA-Seq Workflow Template" 
author: ""
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output:
  BiocStyle::html_document:
    toc_float: true
    code_folding: show
package: systemPipeR
vignette: |
  %\VignetteIndexEntry{WF: RNA-Seq Workflow Template}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
fontsize: 14pt
bibliography: bibtex.bib
---

<!--
Rscript -e "rmarkdown::render('systemPipeRNAseq.Rmd', c('BiocStyle::html_document'), clean=F); knitr::knit('systemPipeRNAseq.Rmd', tangle=TRUE)"; Rscript -e "rmarkdown::render('systemPipeRNAseq.Rmd', c('BiocStyle::pdf_document'))"
-->

```{css, echo=FALSE}
pre code {
white-space: pre !important;
overflow-x: scroll !important;
word-break: keep-all !important;
word-wrap: initial !important;
}
```


```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
options(width=60, max.print=1000)
knitr::opts_chunk$set(
    eval=as.logical(Sys.getenv("KNITR_EVAL", "TRUE")),
    cache=as.logical(Sys.getenv("KNITR_CACHE", "TRUE")), 
    tidy.opts=list(width.cutoff=60), tidy=TRUE)
```

# Introduction

Users want to provide here background information about the design of their RNA-Seq project.

# Create the workflow
To initiate a RNAseq workflow, this entire Rmarkdown file will be imported as a workflow object `sysargList`, or 
referred as the `sal` object by using the `importWF("systemPipeRNAseq.Rmd")` command.

This template provides some common steps for a RNAseq workflow. One can add, remove, modify 
workflow steps by operating on the `sal` object. Conduct the 
[main vignette](xxxxxx)
for details of these functions

In this template, code chunks with option `spr='sysargs'` (commandline step) or 
`spr='r'` will be added to the workflow. Other code chunks will be ignored. We 
may provide more than one alternatives for each step, for example, different mapping 
methods, running locally or on cluster. However, only **one** method will be used 
as default (with `spr` option). If one would like to use other alternatives, cut the 
`spr` option in default code chunk and paste to the alternative code chunks. 


# Samples and environment settings

## Environment settings and input data

Typically, the user wants to record here the sources and versions of the
reference genome sequence along with the corresponding annotations. In
the provided sample data set all data inputs are stored in a `data`
subdirectory and all results will be written to a separate `results` directory,
while the `systemPipeRNAseq.Rmd` script and the `targets` file are expected to be 
located in the parent directory. The R session is expected to run from this parent directory.

[*systemPipeRdata*](http://bioconductor.org/packages/release/data/experiment/html/systemPipeRdata.html) package is a helper package to generate a fully populated [*systemPipeR*](http://bioconductor.org/packages/release/bioc/html/systemPipeR.html)
workflow environment in the current working directory with a single command. 
All the instruction for generating the workflow are provide in the *systemPipeRdata* vignette [here](http://www.bioconductor.org/packages/devel/data/experiment/vignettes/systemPipeRdata/inst/doc/systemPipeRdata.html#1_Introduction). 

The mini sample FASTQ files used by this report as well as the associated reference genome files
can be loaded via the *systemPipeRdata* package. 
The chosen data set [SRP010938](http://www.ncbi.nlm.nih.gov/sra/?term=SRP010938)
contains 18 paired-end (PE) read sets from *Arabidposis thaliana*
[@Howard2013-fq]. To minimize processing time during testing, each FASTQ
file has been subsetted to 90,000-100,000 randomly sampled PE reads that
map to the first 100,000 nucleotides of each chromosome of the *A.
thalina* genome. The corresponding reference genome sequence (FASTA) and
its GFF annotation files have been truncated accordingly. This way the entire 
test sample data set is less than 200MB in storage space. A PE read set has been
chosen for this test data set for flexibility, because it can be used for testing both types
of analysis routines requiring either SE (single end) reads or PE reads.



# Start of workflow steps
By reaching this point, it is assumed that:

1. In a testing case, the workflow environment has been created by the `systemPipeRdata::genWorkenvir`.
2. In a real case, the data and content of the `targets` file have been replaced with real data. 
3. Make modifications of following steps if needed and save the file, otherwise 
   create the workflow and load the steps by 
   `systemPipeR::importWF("systemPipeRNAseq.Rmd", overwrite=TRUE)`.
4. If the workflow project is created by the previous step and some progress has been 
   made, to resume/continue the workflow, **DO NOT** use No.3 here but use 
   `sal <- SPRproject(restart=TRUE)` instead. Template only needs to be imported 
   to SPR project once.


Two keywords may appear under each step:

- **required**: This step is important for the workflow and downstream step(s) 
  depend on this step. 
- **optional**: By default this step is included in the workflow, but can be removed by 
  deleting the `spr='xxx'` option at the code chunk header. Workflow can continue
  without this step. 
- **alternatives**: There are more than one way to complete this step, if the 
  alternative is selected, one would need to add the `spr` option to the alternative 
  code chunk and delete the `spr` option from the default code chunk.

## Required packages and resources

The `systemPipeR` package needs to be loaded [@H_Backman2016-bt].

```{r load_SPR, message=FALSE, spr='r', eval=FALSE}
library(systemPipeR)
```

## Read quality filtering and trimming

**optional**, **alternatives**

### Option 1 trimmomatic

```{r trimming, spr='sysargs', eval=FALSE}
targetspath <- "targetsPE.txt"
appendStep(sal) <- SYSargsList(
    targets=targetspath, 
    wf_file = "trimmomatic/trimmomatic-pe.cwl", input_file = "trimmomatic/trimmomatic-pe.yml",
    dir_path= system.file("extdata/cwl", package = "systemPipeR"),
    inputvars=c(FileName1="_FASTQ_PATH1_", FileName2="_FASTQ_PATH2_", SampleName="_SampleName_")
)
```

### Option 2 built-in trimming function

**Dani change here, not sure the best way, how we can update the targets if operated by Linewise steps like here**

If you want to use this option, change the header to 
`{r trimming, spr='r', eval=FALSE}` and change the header of option 1 to `{r eval=FALSE}`.

```{r eval=FALSE}
targets <- read.csv("targetsPE.txt", sep = "\t", comment.char = "#")
preprocessReads(args=unlist(targets[, 1:2]), Fct="trimLRPatterns(Rpattern='GCCCGGGTAA', 
                subject=fq)", batchsize=100000, overwrite=TRUE, compress=TRUE)
writeTargetsout(x=trim, file="targets_trim.txt", step = 1, 
                new_col = c("FileName1", "FileName2"), new_col_output_index = c(1, 2), overwrite = TRUE)
```

## FASTQ quality report

**optional**

The following `seeFastq` and `seeFastqPlot` functions generate and plot a series of useful 
quality statistics for a set of FASTQ files including per cycle quality box
plots, base proportions, base-level quality trends, relative k-mer
diversity, length and occurrence distribution of reads, number of reads
above quality cutoffs and mean quality distribution. The results are
written to a PDF file named `fastqReport.pdf`.

**bug here, always gives empty list**
```{r fastq_report, eval=FALSE, message=FALSE, spr='r', spr.dep='trimming'}
Sys.sleep(10)
# fqlist <- seeFastq(fastq=outfiles(sal['trimming'])[[1]][, 1], batchsize=10000, klength=8)
# pdf("./results/fastqReport.pdf", height=18, width=4*length(fqlist))
# seeFastqPlot(fqlist)
# dev.off()
``` 


## Build `HISAT2`index

**required**

```{r hisat_index, eval=FALSE, spr='sysargs', spr.dep='load_SPR'}
appendStep(sal) <- SYSargsList(
  step_name = "Index", dir = FALSE, targets=NULL, 
  wf_file = "hisat2/hisat2-index.cwl", 
  input_file="hisat2/hisat2-index.yml",
  dir_path=system.file("extdata/cwl", package = "systemPipeR")
)
```

## HISAT2 mapping

**required**

If the trimming step is **skipped**:

```{r hisat_mapping, eval=FALSE, spr='sysargs', spr.dep='hisat_index'}
targetspath <- "targetsPE.txt"
appendStep(sal) <- SYSargsList(
  targets=targetspath, dir=TRUE, 
  wf_file = "workflow-hisat2/workflow_hisat2-pe.cwl",
  input_file="workflow-hisat2/workflow_hisat2-pe.yml",
  dir_path=system.file("extdata/cwl", package = "systemPipeR"),
  inputvars=c(FileName1="_FASTQ_PATH1_", FileName2="_FASTQ_PATH2_", SampleName="_SampleName_"),
  rm_targets_col = c("FileName1", "FileName2")
)
```

If the trimming step is **not skipped**:

Change the header to `{r hisat_mapping, eval=FALSE, spr='sysargs', spr.dep='trimming;hisat_index'}`
and change the header of the previous R chunk  to `{r eval=FALSE}`
```{r eval=FALSE}
appendStep(sal) <- SYSargsList(
  targets="trimming", dir=TRUE, 
  wf_file = "workflow-hisat2/workflow_hisat2-pe.cwl",
  input_file="workflow-hisat2/workflow_hisat2-pe.yml",
  dir_path=system.file("extdata/cwl", package = "systemPipeR"),
  inputvars=c(trimmomatic_1_paired="_FASTQ_PATH1_", trimmomatic_2_paired="_FASTQ_PATH2_", SampleName="_SampleName_"),
  rm_targets_col = c("FileName1", "FileName2")
)
```


## Read and alignment stats

**optional**

The following provides an overview of the number of reads in each sample
and how many of them aligned to the reference.

**Dani, fix bug here**
```{r align_stats, eval=FALSE, spr='r', spr.dep='hisat_mapping'}
1+1
# read_statsDF <- alignStats(args=sal$stepsWF$hisat_mapping) 
# write.table(read_statsDF, "results/alignStats.xls", row.names=FALSE, quote=FALSE, sep="\t")
```


## Create symbolic links for viewing BAM files in IGV

**optional**
 
The `symLink2bam` function creates symbolic links to view the BAM alignment files in a
genome browser such as IGV. The corresponding URLs are written to a file
with a path specified under `urlfile` in the `results` directory.

Not included in default workflow, change the chunk header to 
`{r bam_urls, eval=FALSE, spr='r', spr.dep='hisat_mapping'}` if this step is needed. 

```{r bam_urls, eval=FALSE}
symLink2bam(sysargs=args, htmldir=c("~/.html/", "somedir/"), 
            urlbase="http://cluster.hpcc.ucr.edu/~tgirke/", 
	        urlfile="./results/IGVurl.txt")
```


## Read counting with `summarizeOverlaps` in parallel mode using multiple cores

Reads overlapping with annotation ranges of interest are counted for
each sample using the `summarizeOverlaps` function [@Lawrence2013-kt]. The read counting is
preformed for exonic gene regions in a non-strand-specific manner while
ignoring overlaps among different genes. Subsequently, the expression
count values are normalized by *reads per kp per million mapped reads*
(RPKM). The raw read count table (`countDFeByg.xls`) and the corresponding 
RPKM table (`rpkmDFeByg.xls`) are written to separate files in the directory of this project. Parallelization is achieved with the `BiocParallel` package, here using 8 CPU cores.

### Create a database for gene annotation

**required**

```{r create_db, eval=FALSE, spr='r', spr.dep='hisat_mapping'}
library("GenomicFeatures"); library(BiocParallel)
(function(){
  # if db is there, skip this step
  if(file.exists("./data/tair10.sqlite")) return(TRUE)
  # otherwise prepare the db
  txdb <- makeTxDbFromGFF(file="data/tair10.gff", format="gff", dataSource="TAIR", organism="Arabidopsis thaliana")
  saveDb(txdb, file="./data/tair10.sqlite")
})()

```

### Read counting

**required**

```{r read_counting, eval=FALSE, spr='r', spr.dep='create_db'}
txdb <- if(exists('txdb')) txdb else loadDb("./data/tair10.sqlite")
outpaths <- outfiles(sal['hisat_mapping'])[[1]][ , 3]
names(outpaths) <- targetsWF(sal)[['hisat_mapping']]$SampleName
eByg <- exonsBy(txdb, by=c("gene"))
bfl <- BamFileList(outpaths, yieldSize=50000, index=character())
multicoreParam <- MulticoreParam(workers=2); register(multicoreParam); registered()
counteByg <- bplapply(bfl, function(x) summarizeOverlaps(eByg, x, mode="Union", 
                                               ignore.strand=TRUE, 
                                               inter.feature=FALSE, 
                                               singleEnd=TRUE)) 
countDFeByg <- sapply(seq(along=counteByg), function(x) assays(counteByg[[x]])$counts)
rownames(countDFeByg) <- names(rowRanges(counteByg[[1]])); colnames(countDFeByg) <- names(bfl)
rpkmDFeByg <- apply(countDFeByg, 2, function(x) returnRPKM(counts=x, ranges=eByg))
write.table(countDFeByg, "results/countDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
write.table(rpkmDFeByg, "results/rpkmDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
```


Note, for most statistical differential expression or abundance analysis
methods, such as `edgeR` or `DESeq2`, the raw count values should be used as input. The
usage of RPKM values should be restricted to specialty applications
required by some users, *e.g.* manually comparing the expression levels
among different genes or features.

## Sample-wise correlation analysis

**optional**

The following computes the sample-wise Spearman correlation coefficients from
the `rlog` transformed expression values generated with the `DESeq2` package. After
transformation to a distance matrix, hierarchical clustering is performed with
the `hclust` function and the result is plotted as a dendrogram
(also see file `sample_tree.pdf`).

```{r sample_tree, eval=FALSE, spr='r', spr.dep='read_counting'}
library(DESeq2, quietly=TRUE); library(ape,  warn.conflicts=FALSE)
countDF <- as.matrix(read.table("./results/countDFeByg.xls"))
colData <- data.frame(row.names=targetsWF(sal['hisat_mapping'])[[1]]$SampleName, condition=targetsWF(sal['hisat_mapping'])[[1]]$Factor)
dds <- DESeqDataSetFromMatrix(countData = countDF, colData = colData, design = ~ condition)
d <- cor(assay(rlog(dds)), method="spearman")
hc <- hclust(dist(1-d))
pdf("results/sample_tree.pdf")
plot.phylo(as.phylo(hc), type="p", edge.col="blue", edge.width=2, show.node.label=TRUE, no.margin=TRUE)
dev.off()
```

![](results/sample_tree.png)
<div align="center">Figure 2: Correlation dendrogram of samples</div></br>

# Analysis of DEGs

The analysis of differentially expressed genes (DEGs) is performed with
the glm method of the `edgeR` package [@Robinson2010-uk]. The sample
comparisons used by this analysis are defined in the header lines of the 
`targets.txt` file starting with `<CMP>`.

## Run `edgeR`

**optional**

```{r run_edger, eval=FALSE, spr='r', spr.dep='read_counting'}
library(edgeR)
countDF <- read.delim("results/countDFeByg.xls", row.names=1, check.names=FALSE) 
cmp <- readComp(stepsWF(sal)[['hisat_mapping']], format="matrix", delim="-")
edgeDF <- run_edgeR(countDF=countDF, targets=targetsWF(sal)[['hisat_mapping']], cmp=cmp[[1]], independent=FALSE, mdsplot="")
```

## Add gene descriptions

**optional**

```{r custom_annot, eval=FALSE, spr='r', spr.dep='run_edger'}
library("biomaRt")
m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
desc <- getBM(attributes=c("tair_locus", "description"), mart=m)
desc <- desc[!duplicated(desc[,1]),]
descv <- as.character(desc[,2]); names(descv) <- as.character(desc[,1])
edgeDF <- data.frame(edgeDF, Desc=descv[rownames(edgeDF)], check.names=FALSE)
write.table(edgeDF, "./results/edgeRglm_allcomp.xls", quote=FALSE, sep="\t", col.names = NA)
```


## Plot DEG results

**optional**

Filter and plot DEG results for up and down regulated genes. The
definition of *up* and *down* is given in the corresponding help
file. To open it, type `?filterDEGs` in the R console.

```{r filter_degs, eval=FALSE, spr='r', spr.dep='custom_annot'}
edgeDF <- read.delim("results/edgeRglm_allcomp.xls", row.names=1, check.names=FALSE) 
pdf("results/DEGcounts.pdf")
DEG_list <- filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=20))
dev.off()
write.table(DEG_list$Summary, "./results/DEGcounts.xls", quote=FALSE, sep="\t", row.names=FALSE)
```

## Venn diagrams of DEG sets

**optional**

The `overLapper` function can compute Venn intersects for large numbers of sample
sets (up to 20 or more) and plots 2-5 way Venn diagrams. A useful
feature is the possibility to combine the counts from several Venn
comparisons with the same number of sample sets in a single Venn diagram
(here for 4 up and down DEG sets).

```{r venn_diagram, eval=FALSE, spr='r', spr.dep='filter_degs'}
vennsetup <- overLapper(DEG_list$Up[6:9], type="vennsets")
vennsetdown <- overLapper(DEG_list$Down[6:9], type="vennsets")
pdf("results/vennplot.pdf")
vennPlot(list(vennsetup, vennsetdown), mymain="", mysub="", colmode=2, ccol=c("blue", "red"))
dev.off()
```

## GO term enrichment analysis

### Obtain gene-to-GO mappings

**optional**

The following shows how to obtain gene-to-GO mappings from `biomaRt` (here for *A.
thaliana*) and how to organize them for the downstream GO term
enrichment analysis. Alternatively, the gene-to-GO mappings can be
obtained for many organisms from Bioconductor’s `*.db` genome annotation
packages or GO annotation files provided by various genome databases.
For each annotation this relatively slow preprocessing step needs to be
performed only once. Subsequently, the preprocessed data can be loaded
with the `load` function as shown in the next subsection.

```{r get_go_annot, eval=FALSE, spr='r', spr.dep='filter_degs'}
library("biomaRt")
(function(){
  if (file.exists("data/GO/catdb.RData")) return(TRUE)
  # listMarts() # To choose BioMart database
  # listMarts(host="plants.ensembl.org")
  m <- useMart("plants_mart", host="plants.ensembl.org")
  listDatasets(m)
  m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
  # listAttributes(m) # Choose data types you want to download
  go <- getBM(attributes=c("go_id", "tair_locus", "namespace_1003"), mart=m)
  go <- go[go[,3]!="",]; go[,3] <- as.character(go[,3])
  go[go[,3]=="molecular_function", 3] <- "F"; go[go[,3]=="biological_process", 3] <- "P"; go[go[,3]=="cellular_component", 3] <- "C"
  go[1:4,]
  dir.create("./data/GO")
  write.table(go, "data/GO/GOannotationsBiomart_mod.txt", quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
  catdb <- makeCATdb(myfile="data/GO/GOannotationsBiomart_mod.txt", lib=NULL, org="", colno=c(1,2,3), idconv=NULL)
  save(catdb, file="data/GO/catdb.RData")
})()

```

### Batch GO term enrichment analysis

**optional**

Apply the enrichment analysis to the DEG sets obtained the above differential
expression analysis. Note, in the following example the `FDR` filter is set
here to an unreasonably high value, simply because of the small size of the toy
data set used in this vignette. Batch enrichment analysis of many gene sets is
performed with the function. When `method=all`, it returns all GO terms passing
the p-value cutoff specified under the `cutoff` arguments. When `method=slim`,
it returns only the GO terms specified under the `myslimv` argument. The given
example shows how a GO slim vector for a specific organism can be obtained from
BioMart.

```{r go_enrich, eval=FALSE, spr='r', spr.dep='get_go_annot'}
library("biomaRt")
load("data/GO/catdb.RData")
DEG_list <- filterDEGs(degDF=edgeDF, filter=c(Fold=2, FDR=50), plot=FALSE)
up_down <- DEG_list$UporDown; names(up_down) <- paste(names(up_down), "_up_down", sep="")
up <- DEG_list$Up; names(up) <- paste(names(up), "_up", sep="")
down <- DEG_list$Down; names(down) <- paste(names(down), "_down", sep="")
DEGlist <- c(up_down, up, down)
DEGlist <- DEGlist[sapply(DEGlist, length) > 0]
BatchResult <- GOCluster_Report(catdb=catdb, setlist=DEGlist, method="all", id_type="gene", CLSZ=2, cutoff=0.9, gocats=c("MF", "BP", "CC"), recordSpecGO=NULL)
library("biomaRt")
m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
goslimvec <- as.character(getBM(attributes=c("goslim_goa_accession"), mart=m)[,1])
BatchResultslim <- GOCluster_Report(catdb=catdb, setlist=DEGlist, method="slim", id_type="gene", myslimv=goslimvec, CLSZ=10, cutoff=0.01, gocats=c("MF", "BP", "CC"), recordSpecGO=NULL)
```

### Plot batch GO term results

**optional**

The `data.frame` generated by `GOCluster` can be plotted with the `goBarplot` function. Because of the
variable size of the sample sets, it may not always be desirable to show
the results from different DEG sets in the same bar plot. Plotting
single sample sets is achieved by subsetting the input data frame as
shown in the first line of the following example.

```{r go_plot, eval=FALSE, spr='r', spr.dep='go_enrich'}
gos <- BatchResultslim[grep("M6-V6_up_down", BatchResultslim$CLID), ]
gos <- BatchResultslim
pdf("GOslimbarplotMF.pdf", height=8, width=10)
goBarplot(gos, gocat="MF")
dev.off()
goBarplot(gos, gocat="BP")
goBarplot(gos, gocat="CC")
```

![](results/GOslimbarplotMF.png)
<div align="center">Figure 5: GO Slim Barplot for MF Ontology</div></br>

## Clustering and heat maps

**optional**

The following example performs hierarchical clustering on the `rlog`
transformed expression matrix subsetted by the DEGs identified in the above
differential expression analysis. It uses a Pearson correlation-based distance
measure and complete linkage for cluster joining.

```{r heatmap, eval=FALSE, spr='r', spr.dep='go_enrich'}
library(pheatmap)
geneids <- unique(as.character(unlist(DEG_list[[1]])))
y <- assay(rlog(dds))[geneids, ]
pdf("heatmap1.pdf")
pheatmap(y, scale="row", clustering_distance_rows="correlation", clustering_distance_cols="correlation")
dev.off()
```

![](results/heatmap1.png)
<div align="center">Figure 6: Heat Map with Hierarchical Clustering Dendrograms of DEGs</div></br>
